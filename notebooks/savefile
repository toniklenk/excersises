# compute

N = 100
# sample number of spikes
# calculate mu
mu = rate_integral(t_min, t_max, rate_max)
# draw spike-counts k from Poisson
K = np.random.poisson(lam=mu, size = N)


# --- rejection sample spike times
# target distribution
def p(t, mu):
    return rate(t, rate_max) / mu

# proposal distribution
def q(t):
    return np.array([1/2 if 0<=t_<=2 else 0 for t_ in t])

spike_times = []

# not vectorized, as every iteration has different number of spikes
for k in K:
    
    # sample x-values from from proposal distribution
    t = np.random.uniform(0.,2., k)
    # sample constants to check against
    Cs = np.random.uniform(0,1, k)
    
    # calculate ratio of target distribution to scales proposal distribution
    mask = p(t, mu) / q(t) > Cs
    spike_times.append(t[mask])
    
    
# plot
fig, (ax1, ax2) = plt.subplots(
    nrows=2, ncols=1, figsize=(8, 6), layout="constrained", sharex=True, sharey=False
)

raster(spike_times, t_max=2, ax=ax1)
hist, bin_edges = np.histogram(np.concat(spike_times), bins = bins_count)
x = (bin_edges+0.01)[1:]
ax2.plot(x, rate(x, rate_max), label="Analytical")
ax2.plot(x, hist / (N * bin_size), label="Numerical")
ax2.set_xlabel("Time[s]")
ax2.set_ylabel("Rate [Hz")
ax2.legend(loc="upper center")
